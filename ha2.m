%% First we generate input data
birthdate = 20030509;    % Write the birth date on format yyyymmdd for oldest member in the group
format compact
[lambdavec,Tvec,cvec] = getSPOdata(birthdate);   %yyyymmdd  Do not use clear command or change the values of these variables

% -------------------------------------------------------------------------------------------------------------------
%% Marginal Allocation
% Question 1 should be answered in the report

cvec = cvec'; % transpose to column vector to use standard notation
svec = zeros(size(lambdavec))';

tol = 1e-9;

for j = 1:length(lambdavec)
    mu = lambdavec(j) * Tvec(j);
    Smax = 10;
    EBOj = EBO_poisson_rec(mu, Smax);   % s=0..10

    % första differens: f(s+1) - f(s)
    d1 = diff(EBOj);         %s=0..9

    % andra differens: d1(s+1) - d1(s)
    d2 = diff(d1);           % längd 9, motsvarar s=0..8

    is_decreasing     = all(d1 <=  tol); 
    is_int_convex     = all(d2 >= -tol); 

    fprintf('LRU %d: decreasing = %d, integer-convex = %d\n', ...
            j, is_decreasing, is_int_convex);
end

% Question 2 should described in the report, and submitted below
% Enter on the format EBO2 is total EBO after adding the spare part 
% Cost2 should be the cost of the added spare part
EBO2 = "to do";    
Cost2 = "to do";    %

Q2 = [EBO2 Cost2]; % Checking both at the same time in grader.

% Question 3, you should describe how the Marginal allocation is
% implemented in your own words in the report, and compute all efficient
% points.

% Question 4 should be answered in the report, with a figure and a table with
% all efficient points
% Furthermore, a table with first five efficient points should be submitted below
 
% Enter on the format EPtable = [ x0 EBO(x0) C(x0); x1 EB0(x1) C(x1); ... x4 EBO(x4) C(x4)]
% Where xj is the row vector with number of spare parts of each kind
% corresponding to the efficient points generated by the Marginal allocation algorithm
% EBO and C are the total values (scalars) for each allocation xj
EPtable = "to do";

function pk = poisson_pmf_vec(mu, eps)
    if nargin < 2
        eps = 1e-12;
    end

    pk = [];          % kommer bli kolumnvektor
    k  = 0;
    p0 = exp(-mu);    % P(N=0)
    pk(1,1) = p0;
    F = p0;

    while F < 1 - eps
        k = k + 1;
        p_next = pk(k) * mu / k;   % rekursiv formel
        pk(k+1,1) = p_next;       % P(N=k)
        F = F + p_next;
    end
end

function EBO = EBO_poisson_rec(mu, Smax)
    % Returnerar vektor EBO(s) för s = 0,...,Smax (längd Smax+1)
    eps = 1e-12;
    pk = poisson_pmf_vec(mu, eps);   % P(N=k), k=0,...,Kmax
    F  = cumsum(pk);                 % F(k+1) = P(N<=k)

    % EBO(0) = E[N] = mu
    EBO = zeros(Smax+1,1);
    EBO(1) = mu;

    for s = 1:Smax
        % P(N >= s) = 1 - P(N <= s-1) = 1 - F(s)
        P_ge_s = 1 - F(s);
        EBO(s+1) = EBO(s) - P_ge_s;
    end
end

function cost = g(s, cvec)
    cost = sum(s(:) .* cvec(:));
end

function totalEBO = f(s, lambdavec, Tvec)
    % s är en rad/kolumnvektor med 9 komponenter: [s1 ... s9]
    totalEBO = 0;
    for j = 1:length(s)
        mu = lambdavec(j) * Tvec(j);
        Smax = s(j);                      
        EBOj_vec = EBO_poisson_rec(mu, Smax);
        totalEBO = totalEBO + EBOj_vec(Smax+1);
    end
end