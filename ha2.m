%% First we generate input data
birthdate = 20030509;    % Write the birth date on format yyyymmdd for oldest member in the group
format compact
[lambdavec,Tvec,cvec] = getSPOdata(birthdate);   %yyyymmdd  Do not use clear command or change the values of these variables

% -------------------------------------------------------------------------------------------------------------------
%% Marginal Allocation
% Question 1 should be answered in the report

cvec = cvec'; % transpose to column vector to use standard notation
svec = zeros(size(lambdavec))';

%Chech that it's decreasing
mu = lambdavec .* Tvec;
EBOprev = inf;
for i=0:10
    svec = svec + ones(size(svec));
    EBO = f(svec, mu);
    diff = EBO - EBOprev;
    EBOprev = EBO;
end

%Check integer convexity
is_integer_convex(svec, mu)

% Question 2 should described in the report, and submitted below
% Enter on the format EBO2 is total EBO after adding the spare part 
% Cost2 should be the cost of the added spare part
EBO2 = "to do";    
Cost2 = "to do";    %

Q2 = [EBO2 Cost2]; % Checking both at the same time in grader.

% Question 3, you should describe how the Marginal allocation is
% implemented in your own words in the report, and compute all efficient
% points.

all_f = zeros(size(lambdavec))'';
best_value = inf;
for j = 1 : 9
    s = zeros(size(lambdavec))'';
    s(j) = 1;

    all_f(j) = f(s, mu);
    candidate = f(s, mu);
    if candidate < best_value
        best_value = candidate;
        best_part = j;
    end
end
fprintf('Best part: %d\n', best_part);

% Question 4 should be answered in the report, with a figure and a table with
% all efficient points
% Furthermore, a table with first five efficient points should be submitted below
 
% Enter on the format EPtable = [ x0 EBO(x0) C(x0); x1 EB0(x1) C(x1); ... x4 EBO(x4) C(x4)]
% Where xj is the row vector with number of spare parts of each kind
% corresponding to the efficient points generated by the Marginal allocation algorithm
% EBO and C are the total values (scalars) for each allocation xj
EPtable = "to do";

function output = EBO_j(s_j, mu_j)    %Retunerar reellt tal EBO_j(s_j) = f_j(s_j)
   
    %initiering
    pk_curr = exp(-mu_j);      % P(X_j = 0)
    EBO_j_curr = mu_j;         % EBO_j(0) = mu_j
    R_j_curr = 1 - pk_curr;    % R_j(0,s_j) = max(0, 0 - s_j) = 0

    %rekursion
    for k = 0 : s_j - 1

        EBO_j_next = EBO_j_curr - R_j_curr;
        pk_next = (mu_j / (k + 1)) * pk_curr;   
        R_j_next = R_j_curr - pk_next;  

        pk_curr = pk_next;
        EBO_j_curr = EBO_j_next;
        R_j_curr = R_j_next;

    end
    
    output = EBO_j_curr;    % sista EBO_j_curr blir EBO_j(s_j)

end

% s = (s1, s2, ...) och mu = (lambda1 * T1, ...)
function output = f(s, mu)     % retunerar summan av alla f_j givet alla s_j och mu_j fÃ¶r varje reservdelstyp
    s_size = size(s);
    f = zeros(s_size(1), 1);
    for j = 1 : length(s)
        f(j) = EBO_j(s(j), mu(j));
    end
    output = sum(f);
end

function bool = is_integer_convex(svec, mu)
    delta_f_prev = -inf;
    diff = zeros(size(svec));
    for i=0:10
        splusone = svec + ones(size(svec));
        delta_f = f(splusone, mu) - f(svec, mu);
        diff(i+1) = delta_f - delta_f_prev;   

        svec = splusone;
    end
    bool = all(diff >= 0);     % Check if all delta_f(s+1) are greater than delta_f(s)

    if bool
        disp("f is integer convex")
    else
        disp("f is NOT integer convex")
    end

end